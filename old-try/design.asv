clc, clear
close all

nRp = 15;
nCon = 25;
nCRp = 20;
ratio = 2.5;

bandwidth = 15 * 2 * pi;

%% Object
K = 493;%1.56 * 180 / pi;
taue = 0.0004;%0.00396;% 0.0039035;
taum = 2.05;%0.09947;%0.984871194396488;
G = tf(K, [taue * taum, taum, 1, 0]);
%% 加入惯性环节
T = 1 / (bandwidth / 2 / pi) / 15; 
Inertial = tf(1, [T, 1]);
G = G * Inertial;

%% 给定频率点
fre = logspace(-1, 2.3) * 2 * pi;  %% 1 - 100
[mag, phi] = bode(G, fre);

data.fre = fre;
data.mag = zeros(length(fre), 1);
data.phi = zeros(length(fre), 1);

for i = 1:length(fre)
    data.mag(i) = 20 * log10(mag(1, 1, i));
    data.phi(i) = phi(1, 1, i);
end

%% 补相位
phi_advance = 30;
phi_advance_margin = 0;
advance = FillPhase(data, ratio, phi_advance, phi_advance_margin, bandwidth);

G_P = G * advance.P;

figurename('前向通道');
margin(G_P);
grid on;
figurename('前向通道闭环');
bode(G_P / (1 + G_P));
grid on

Design_Lowgain;

phi_creg = 8;
mag_creg = 0.8;
philim = 8;
maglim = 0.7;
num_max = 3;
flag_add = 1; % 1: mag, 2: phi
bfailure_pre = 0;
trap_pre = 0;
later_pre = 0;
while 1
    [trap, later, bfailure, data_check, num] = wave_repair(advance.P * Glow, G, 0, bandwidth * ratio, 0, bandwidth, phi_creg, mag_creg, num_max);
    if bfailure == -1 && bfailure_pre == 1
        break;
    end
    bfailure_pre = bfailure;
    if bfailure == 1
        trap_pre = trap;
        later_pre = later;
        %% 性能调优，力图做到更好的数值指标
        if num <= 2
            num_max = min(3, num + 1);
        end
        if flag_add == 1
            mag_creg = mag_creg / 1.05;
            flag_add = 2;
        elseif flag_add == 2
            phi_creg = phi_creg / 1.05;
            flag_add = 1;
        end
    else 
        %% 放宽要求，为了前馈和前置滤波器做准备，其中相频优先保证
         if flag_add == 1
            mag_creg = mag_creg * 1.05;
            flag_add = 2;
        elseif flag_add == 2
            phi_creg = phi_creg * 1.05;
            flag_add = 1;
        end
    end
end

K = advance.P * later_pre.G * Glow;
for i = 1 : trap_pre.num
    K = K * trap_pre.G(i);
end
figurename('第一次');
margin(advance.P * later_pre.G * G);
grid on
figurename('陷波滤波器');
margin(K * G);
grid on
figurename('陷波滤波器闭环');
bode(K * G / (1 + K * G));
grid on

k = 493;%1.56 * 180 / pi;
taue = 0.0004;%0.00396;% 0.0039035;
taum = 2.05;%0.09947;%0.984871194396488;
G = tf(k, [taue * taum, taum, 1, 0]);
%% 加入惯性环节
T = 1 / (bandwidth / 2 / pi) / 15; 
Inertial = tf(1, [T, 1]);

K = K * Inertial;

%% 顺馈
para_aux1 = 500;
para_aux2 = 500;
if mag_creg > 20 * log10(1 + maglim)  || phi_creg > philim
    option.type = 'transfer-function';
    [forward, exitflag] = design_forward(K, G, 0, 0, 0, 0, 0.7, bandwidth, maglim, philim, para_aux1, para_aux2, option);
    figurename('顺馈');
    bode((K * G + G * forward.G)/ (1 + K * G));
    grid on
end


%% 检查阶跃特性
t = 0 : 0.0005 : 10;
u = ones(length(t), 1) * 3;
out = lsim((K * G + G * forward.G)/ (1 + K * G), u, t);
out1 = lsim((K * G)/ (1 + K * G), u, t);
figurename('阶跃');
plot(t, u, 'r');
hold on
grid on
plot(t, out, 'b');
hold on
plot(t, out1, 'g');

%% 输出controller
TSp = 0.0005;
% 惯性环节
[dNumd,dDend] = c2dm(1, Inertial.Denominator{1,1}, TSp, 'tustin');
fid = fopen('controller.txt', 'wt+');
fprintf(fid, '%.12f, %.12f, %.12f, %.12f, %.12f, 直接\n',dNumd(1),dNumd(2),dNumd(3));

% later
a = later_pre.G.Numerator{1, 1};
b = later_pre.G.Denominator{1, 1};
[dNuml,dDenl] = c2dm(a, b, TSp, 'tustin');
fprintf(fid, '%.12f, %.12f, %.12f, %.12f, %.12f, 迟后\n', -dDenl(2),dNuml(1),dNuml(2), 0, 0);
% trap
for i = 1 : trap_pre.num
    a = [1, trap_pre.e(i) * trap_pre.T(i), trap_pre.f(i) * trap_pre.f(i)];
    b = [1, trap_pre.T(i), trap_pre.f(i) * trap_pre.f(i)];
    [dNumt,dDent] = c2dm(a, b, TSp, 'tustin');
    fprintf(fid, '%.12f, %.12f, %.12f, %.12f, %.12f, 陷波\n',-dDent(2),-dDent(3),dNumt(1),dNumt(2),dNumt(3));
end
% forward
a = [taum, 1];
b = [taue, 1];
a_aux = [1 / (para_aux1 * 2 * pi), 1];
b_aux = [1 / (para_aux2 * 2 * pi), 1];
[dNumf, dDenf] = c2dm(a, a_aux, TSp, 'tustin');
fprintf(fid, '%.12f, %.12f, %.12f, %.12f, %.12f, 前馈\n', -dDenf(2),dNumf(1),dNumf(2), 0, 0);
[dNumf, dDenf] = c2dm(b, b_aux, TSp, 'tustin');
fprintf(fid, '%.12f, %.12f, %.12f, %.12f, %.12f, 前馈\n', -dDenf(2),dNumf(1),dNumf(2), 0, 0);
fprintf(fid, '%.12f, %.12f, %.12f, %.12f, %.12f, 前馈增益\n',forward.K / k,0,0,0,0);

%% 迟后
for i = 1 : LowGain.count
    tau = 1 / (sqrt(LowGain.alpha(i)) * LowGain.fre(i));
    [dNuml,dDenl] = c2dm([tau, 1], [LowGain.alpha(i) * tau, 1], TSp, 'tustin');
    fprintf(fid, '%.12f, %.12f, %.12f, %.12f, %.12f, 低频迟后\n',-dDenl(2),dNuml(1),dNuml(2), 0, 0);
end
fprintf(fid, '%.12f, %.12f, %.12f, %.12f, %.12f, 低频增益\n',LowGain.K,0,0,0,0);

fclose(fid);

autoArrangeFigures



